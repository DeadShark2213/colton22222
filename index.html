<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gorilla Game</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
        }
        canvas { 
            display: block; 
        }
        .hide-cursor {
            cursor: none;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, gorilla, basePlate, stick;
        let isJumping = false;
        let jumpVelocity = 0.2; 
        let gravity = -0.01; 
        let groundY = 0.5; 
        const trees = []; 
        let stickPickedUp = false; 

        let mouseX = 0;
        let mouseY = 0;
        const sensitivity = 0.03; 
        let yaw = 0; 
        let pitch = 0; 

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB); 
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 7.5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            const plateGeometry = new THREE.BoxGeometry(200, 0.1, 200); 
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            basePlate = new THREE.Mesh(plateGeometry, plateMaterial);
            basePlate.position.y = -0.05;
            scene.add(basePlate);

            gorilla = new THREE.Group();
            const bodyGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            gorilla.add(body);

            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 32);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3, -0.5, 0);
            gorilla.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3, -0.5, 0);
            gorilla.add(rightLeg);

            gorilla.position.set(0, groundY + 0.5, 0); 
            scene.add(gorilla);

            addLargeTrees();
            addStick();
            addMineShaft(); // Add the mine shaft

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            document.addEventListener('fullscreenchange', onFullscreenChange);

            animate();
        }

        function addLargeTrees() {
            const treeTrunkGeometry = new THREE.CylinderGeometry(0.5, 0.75, 10, 8); 
            const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const treeLeavesGeometry = new THREE.SphereGeometry(1.5, 16, 16); 
            const treeLeavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });

            const treePositions = [
                { x: -20, z: 0 },
                { x: -15, z: -5 },
                { x: -10, z: 5 },
                { x: -5, z: 0 },
                { x: 0, z: -15 },
                { x: 5, z: -5 },
                { x: 15, z: 5 },
                { x: 20, z: 0 },
            ];

            treePositions.forEach(pos => {
                const trunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
                trunk.position.set(pos.x, 5, pos.z);
                scene.add(trunk);
                trees.push(trunk); 

                const leaves = new THREE.Mesh(treeLeavesGeometry, treeLeavesMaterial);
                leaves.position.set(pos.x, 10, pos.z); 
                scene.add(leaves);
            });
        }

        function addStick() {
            const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 16); 
            const stickMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); 
            stick = new THREE.Mesh(stickGeometry, stickMaterial);
            stick.position.set(0, 1, 0); 
            scene.add(stick);
        }

        function addMineShaft() {
            // Create the main shaft structure
            const shaftGeometry = new THREE.BoxGeometry(4, 10, 4);
            const shaftMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const mineShaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            mineShaft.position.set(0, 5, -20);
            scene.add(mineShaft);
            
            // Create support beams
            const beamGeometry = new THREE.BoxGeometry(0.2, 6, 0.2);
            const beamMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const beams = [];

            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                    beam.position.set(i * 1.5, 3, j * 1.5);
                    scene.add(beam);
                    beams.push(beam);
                }
            }

            // Create a railroad track
            const trackGeometry = new THREE.BoxGeometry(0.5, 0.1, 20);
            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9 });
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.y = Math.PI / 4; // Angle the track
            track.position.set(0, -5, -10);
            scene.add(track);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateGorillaPosition(); 
            applyWalkingAnimation(); 

            gorilla.rotation.y = yaw; 
            camera.position.x = gorilla.position.x + 5 * Math.sin(yaw);
            camera.position.z = gorilla.position.z + 5 * Math.cos(yaw);
            camera.position.y = gorilla.position.y + pitch; 
            camera.lookAt(gorilla.position); 

            if (stickPickedUp) {
                stick.position.set(0, 1.5, 0); 
                gorilla.children[2].position.y = -0.3; // Raise the right leg
            } else {
                gorilla.children[2].position.y = -0.5; // Reset to normal
            }

            if (isJumping) {
                gorilla.position.y += jumpVelocity;
                jumpVelocity += gravity;
                if (gorilla.position.y <= groundY + 0.5) {
                    gorilla.position.y = groundY + 0.5; 
                    isJumping = false; 
                    jumpVelocity = 0.2; 
                }
            }

            trees.forEach(tree => {
                if (checkCollision(gorilla, tree)) {
                    gorilla.position.sub(movement.clone().multiplyScalar(0.1));
                }
            });

            renderer.render(scene, camera);
        }

        let movement = new THREE.Vector3();
        let angle = 0; 

        function onKeyDown(event) {
            switch (event.key) {
                case 'w':
                    movement.z = -1; 
                    break;
                case 's':
                    movement.z = 1; 
                    break;
                case ' ':
                    if (!isJumping) {
                        isJumping = true; 
                        jumpVelocity = 0.4; 
                    }
                    break;
                case 'e': 
                    if (!stickPickedUp && isCloseToStick()) { 
                        stickPickedUp = true; 
                        scene.remove(stick); 
                        console.log("Stick picked up!");
                    }
                    break;
                case 'Control': 
                    if (stickPickedUp) {
                        stickPickedUp = false; 
                        stick.position.set(gorilla.position.x, 1, gorilla.position.z);
                        scene.add(stick); 
                        console.log("Stick dropped!");
                    }
                    break;
                case 'Escape':
                    if (document.fullscreenElement) {
                        document.exitFullscreen(); 
                        if (document.pointerLockElement) {
                            document.exitPointerLock(); 
                        }
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key) {
                case 'w':
                case 's':
                    movement.z = 0; 
                    break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement) {
                mouseX = event.movementX || 0;
                mouseY = event.movementY || 0;
                yaw -= mouseX * sensitivity; 
                pitch -= mouseY * sensitivity; 
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        }

        function isCloseToStick() {
            const distance = gorilla.position.distanceTo(stick.position);
            return distance < 1; 
        }

        function updateGorillaPosition() {
            const speed = 0.1; 
            const newPosition = new THREE.Vector3().copy(gorilla.position);
            newPosition.x += (movement.z * Math.sin(gorilla.rotation.y)) * speed;
            newPosition.z += (movement.z * Math.cos(gorilla.rotation.y)) * speed;

            const futureGorilla = gorilla.clone();
            futureGorilla.position.copy(newPosition);
            let collisionDetected = false;
            trees.forEach(tree => {
                if (checkCollision(futureGorilla, tree)) {
                    collisionDetected = true; 
                }
            });

            if (!collisionDetected) {
                gorilla.position.copy(newPosition);
            }
        }

        function applyWalkingAnimation() {
            if (movement.z !== 0) { 
                angle += 0.1; 
                const legMovement = Math.sin(angle);
                gorilla.children[1].position.y = -0.5 + legMovement * 0.1; 
                gorilla.children[2].position.y = -0.5 - legMovement * 0.1; 
            } else {
                gorilla.children[1].position.y = -0.5; 
                gorilla.children[2].position.y = -0.5; 
            }
        }

        function checkCollision(gorilla, tree) {
            const gorillaBox = new THREE.Box3().setFromObject(gorilla);
            const treeBox = new THREE.Box3().setFromObject(tree);
            return gorillaBox.intersectsBox(treeBox);
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('dblclick', function() {
            const element = document.body;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            if (element.requestPointerLock) {
                element.requestPointerLock();
                document.body.classList.add('hide-cursor'); 
            }
        });

        function onFullscreenChange() {
            if (document.fullscreenElement) {
                document.body.requestPointerLock(); 
                document.body.classList.add('hide-cursor'); 
            } else {
                document.exitPointerLock(); 
                document.body.classList.remove('hide-cursor'); 
            }
        }

        init();
    </script>
</body>
</html>
